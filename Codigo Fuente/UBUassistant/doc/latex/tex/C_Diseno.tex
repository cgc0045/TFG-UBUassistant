\apendice{Especificación de diseño}

\section{Introducción}

La especificación de diseño detalla la estructura de los datos, los procedimientos y la arquitectura.

\section{Diseño de datos}

En el sistema se pueden diferencias dos entidades relacionadas:

\begin{itemize}
\tightlist
\item \textbf{CaseDescription:} esta entidad es la encargada de almacenar la descripción de los casos para el algoritmo de inteligencia artificial. Como atributos tiene un identificador y cinco palabras clave.
\item \textbf{CaseSolution:} esta entidad es la encargada de almacenar la respuesta para cada uno de los casos descriptivos. Como atributos tiene un identificador y una respuesta.
\end{itemize}

Estas entidades no están relacionadas mediante el uso de claves externas, si no que es Hibernate el encargado de relacionarlas.

\imagenLarga{DiagramaER.png}{Diagrama E/R.}

Además de las entidades anteriormente mencionadas, el sistema consta de más representaciones de tablas.

\imagenLarga{DiagramaEER.png}{Entidades del sistema.}

\section{Diseño procedimental}

El diseño procedimental detalla cómo interaccionan los distintos participantes de un algoritmo.

En este caso, para explicar cómo trabajan los diferentes componentes del algoritmo de búsqueda de respuesta, se elaboran cuatro diagrama de secuencia, uno por cada comportamiento del algoritmo.

\imagenLarga{DiagramaSecuenciaReservedWord.png}{Diagrama secuencia algoritmo para una palabra reservaba.}
\imagenLarga{DiagramaSecuenciaOneAnswer.png}{Diagrama secuencia algoritmo para una respuesta.}\imagenLarga{DiagramaSecuenciaMultipleAnswers.png}{Diagrama secuencia algoritmo para múltiples respuestas.}\imagenLarga{DiagramaSecuenciaNoAnswerSuggestions.png}{Diagrama secuencia algoritmo cuando no hay respuestas.}

\section{Diseño arquitectónico}

Al desarrollarse una aplicación web, desde un primer momento se decidió utilizar el patrón \emph{MVC}, obteniendo una arquitectura que mantiene la independencia de los datos, la lógica y la interfaz.

\subsection{Modelo Vista Controlador}

Modelo vista controlador (\emph{MVC}) es un patrón arquitectónico que nos ayuda a separar los datos, la lógica de negocio y la interfaz de usuario \cite{mvc:wiki}.

\imagen{MVC}{Diagrama de clases MVC}

Sus componentes son los siguientes:

\begin{itemize}
\tightlist
\item
  \textbf{modelo:} representa los datos y la lógica de negocio.
\item
  \textbf{vista:} presenta la información del modelo.
\item
  \textbf{controlador:} controla las entradas del usuario y selecciona la vista.
\end{itemize}

\imagen{MVC-Process}{Diagrama de interacción MVC \cite{mvc:info}}

Aplicando estos conceptos a una aplicación web realizada mediante JSP con una base de datos como sistema de persistencia, podemos obtener el siguiente diagrama.

\imagen{MVCjsp}{Diagrama de MVC específico de una aplicación web JSP}


\subsection{Arquitectura web}

La arquitectura elegida para el desarrollo de la aplicación web fue JSP.

La arquitectura JSP (\emph{JavaServer Pages}) permite la creación de páginas web dinámicas con llamadas al servidor, donde se alojan las clases Java \cite{jsp:wiki}.

\imagen{jsp-arch}{Arquitectura JSP \cite{jsp:arq}}

\subsection{Estructura de paquetes}

Los paquetes que contiene el sistema agrupan todas las clases que comparten funcionalidad. Esta agrupación facilita la comprensión del sistema quedando todas las clases que realizan operaciones similares bajo un nombre descriptivo de paquete.

Se ha seguido esta convención tanto en los paquetes del código fuente como en los paquetes de código de pruebas.

\imagen{DiagramaPaquetes.png}{Diagrama de paquetes.}

\begin{itemize}
\tightlist
\item \textbf{cbr:} el paquete cbr contiene la clase que posee la lógica del algoritmo de inteligencia artificial.
\item \textbf{database:} este paquete contiene las clases que se comunican con la base de datos. \emph{DatabaseAdministration} es la clase que se comunicará con la base de datos para la interfaz de administración mientras que \emph{DatabaseConection} lo hará para la interfaz del asistente virtual.
\item \textbf{handler:} el paquete handler contiene la clase que hará de intermediaria entre la interfaz de la página jsp con la clase del algoritmo de inteligencia artificial.
\item \textbf{storage:} este paquete contiene la clase encargada de almacenar el texto que es mostrado al usuario en la interfaz del asistente virtual.
\item \textbf{representation:} contiene las clases del modelo que serán mapeadas y usadas por el algoritmo de inteligencia artificial para comunicarse con la base de datos.
\item \textbf{util:} el paquete util contiene una clase general que se encarga de comparar los objetos devueltos por el algoritmo de inteligencia artificial, discriminando por su similitud con la pregunta.
\end{itemize}

\imagen{DiagramaPaquetesTest.png}{Diagrama de paquetes de test.}

Cabe destacar que todos los paquetes contienen test unitarios. El paquete \emph{selenium} almacena los test de interfaz. No se incluyen test de de los paquetes \emph{cbr} y \emph{handler} ya que las clases que contienen deben ejecutarse en un entorno web.

\subsection{Navegabilidad}

La aplicación tiene dos interfaces claramente diferenciadas, el asistente virtual y la página de administración.

Desde una hipotética página web con acceso a las dos interfaces obtendríamos un diagrama de navegabilidad:

\imagen{DiagramaNavegabilidad.png}{Diagrama de navegabilidad.}

\subsection{Colores}

La elección de colores se ha basado en el enfoque dado al proyecto hacia la Universidad de Burgos. Por ello se han elegido los colores principales de los sitios web de la universidad que además confieren un contraste alto y no agresivo sobre el texto.

\imagen{Colores.png}{Colores.}